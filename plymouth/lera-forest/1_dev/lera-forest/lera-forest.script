/*
Theme Name: lera-forest
Version: 1.0
Description: Mod from FEDORA-CORE-9-BOOT-SPLASH-PORT
Author: Valeria Fadeeva - https://github.com/Valeria-Fadeeva
Date: 2022.05.02
License: GNU AFFERO GENERAL PUBLIC LICENSE, see <http://www.gnu.org/licenses/>
*/

x0 = Window.GetX();
y0 = Window.GetY();

Window.GetMaxWidth = fun() {
    i = 0;
    width = 0;
    while (Window.GetWidth(i)) {
        width = Math.Max(width, Window.GetWidth(i));
        i++;
    }
    return width;
};

Window.GetMaxHeight = fun() {
    i = 0;
    height = 0;
    while (Window.GetHeight(i)) {
        height = Math.Max(height, Window.GetHeight(i));
        i++;
    }
    return height;
};

fun percent(perc, pixels) {
    result = Math.Int(Math.Abs(Math.Int(pixels)) / 100 * Math.Abs(Math.Int(perc)));
    return result;
}

// Ширина экрана, например 1920
screen.width =  Window.GetMaxWidth();

// Выстота экрана, например 1080
screen.height = Window.GetMaxHeight();

// Соотношение сторон экрана
screen.ratio =  screen.width / screen.height;

// BACKGROUND
background.image =  Image("BACKGROUND.PNG");
background.width =  background.image.GetWidth();
background.height = background.image.GetHeight();
background.ratio =  background.width / background.height;

if (background.ratio == 1 || (background.width < 600 && background.height < 600)) {
    background.sc.scaled = background.image.Scale(screen.width, screen.height);
} else {
    factor = 0;

    if (screen.ratio < background.ratio) {
        factor = screen.height / background.height;
    } else {
        factor = screen.width / background.width;
    }

    background.sc.scaled = background.image.Scale(background.width * factor, background.height * factor);
}

background.sc.width = background.sc.scaled.GetWidth();
background.sc.height = background.sc.scaled.GetHeight();

background.sp.sprite = Sprite(background.sc.scaled);
background.sp.x = Math.Int(screen.width / 2 - background.sc.width / 2);
background.sp.y = Math.Int(screen.height / 2 - background.sc.height / 2);
background.sp.sprite.SetPosition(background.sp.x, background.sp.y);

/* Максимальная ширина и высота для лого в процентах и пикселях

Например 30% от экрана

*/

limit.percent = 30;

limit.width = percent(limit.percent, screen.width);
limit.height = percent(limit.percent, screen.height);

// LOGO
logo.image = Image("MAIN-LOGO.PNG");
logo.width = logo.image.GetWidth();
logo.height = logo.image.GetHeight();

ma = Math.Max(logo.width, logo.height);
mi = Math.Min(limit.width, limit.height);
m_factor = ma / mi;

logo.sc.scaled = logo.image.Scale(logo.width / m_factor, logo.height / m_factor);
logo.sc.width = logo.sc.scaled.GetWidth();
logo.sc.height = logo.sc.scaled.GetHeight();

logo.sp.sprite = Sprite(logo.sc.scaled);
logo.sp.sprite.SetOpacity(1);
logo.sp.x = percent(50, screen.width) - logo.sc.width / 2;
logo.sp.y = percent(50, screen.height) - logo.sc.height / 2;
logo.sp.sprite.SetPosition(logo.sp.x, logo.sp.y, 1);

// SHOW-DETAILS
show_details.image = Image("SHOW-DETAILS.PNG");
show_details.sp.sprite = Sprite(show_details.image);
show_details.sp.x = logo.sp.x;
show_details.sp.y = logo.sp.y + logo.sc.height + 10;
show_details.sp.sprite.SetPosition(show_details.sp.x, show_details.sp.y, 5);

// SPINNER
SpriteImage = fun(asset) {
    local.sprite = Sprite();
    sprite.image = Image(asset);
    sprite.width = sprite.image.GetWidth();
    sprite.height = sprite.image.GetHeight();
    sprite.SetImage(sprite.image);
    return sprite | global.SpriteImage;
} | Sprite;

SpriteImage.SetSpriteImage = fun(image) {
    this.image = image;
    this.width = image.GetWidth();
    this.height = image.GetHeight();
    this.SetImage(this.image);
};

assets.spinner_base = "";

Spinner = fun() {
    // FIXME: try to use this=
    spinner = global.Spinner | [];
    spinner.count = 120;
    spinner.current_idx = 0;
    spinner.last_time = 0;
    spinner.steps = 10.0; // We render degrees in increments of 10 to save disk.
    spinner.duration = 3.0; // Seconds per rotation.
    for (i = 0; i <= spinner.count; ++i) {
        if (i % spinner.steps != 0) {
            continue;
        }

        spinner[i] = SpriteImage(assets.spinner_base + "THROBBER-ANIM-" + i + ".PNG");
        spinner[i].x = logo.sp.x + logo.sc.width - spinner[i].GetImage().GetWidth();
        spinner[i].y = logo.sp.y + logo.sc.height + 10;
        spinner[i].SetPosition(spinner[i].x, spinner[i].y, 9);
        spinner[i].SetOpacity(0);
    }
    return spinner;
} | [];

Spinner.Animate = fun(time) {
    degrees = Math.Int(((2 * Math.Pi / duration) * time) * (180 / Math.Pi));
    new_ = degrees % count;
    old_ = current_idx;

    if (Math.Int(new_) < Math.Int((old_ + steps) % count)) {
        // Every $steps degrees we can render a frame, all others we skip.
        return;
    }

    // We set a second new which is now a correct index bump by coercing it
    // into a multiple of 10.
    new_ = Math.Int(new_ / steps) * steps;
    // Debug("going from " + old_ + " to " + new_);
    // dps = time - last_time;
    // DebugMedium("dps " + dps*35);
    // last_time = time;

    this[old_].SetOpacity(0);
    this[new_].SetOpacity(1);
    current_idx = new_;
    return this;
};

Spinner.GetY = fun() {
    return this[0].GetY();
};

Spinner.GetHeight = fun() {
    return this[0].height;
};

global.spin = Spinner();

// PROGRESS BAR
progress_bar.image = Image("PROGRESS_BAR.PNG");
progress_bar.width = progress_bar.image.GetWidth();
progress_bar.height = progress_bar.image.GetHeight();

progress_bar.sp.sprite = Sprite();
progress_bar.sp.x = percent(50, screen.width) - progress_bar.width / 2;
progress_bar.sp.y = show_details.sp.y + show_details.height + 10 + progress_bar.height / 2;
progress_bar.sp.sprite.SetPosition(progress_bar.sp.x, progress_bar.sp.y, 6);

progress_box.image = Image("PROGRESS_BOX.PNG");
progress_box.width = progress_box.image.GetWidth();
progress_box.height = progress_box.image.GetHeight();

progress_box.sp.sprite = Sprite(progress_box.image);
progress_box.sp.x = percent(50, screen.width) - progress_box.width / 2;
progress_box.sp.y = show_details.sp.y + show_details.height + 10 + progress_box.height / 2;
progress_box.sprite.SetPosition(progress_box.sp.x, progress_box.sp.y, 5);

fun progress_callback(duration, progress) {
    if (progress_bar.width != Math.Int(346 * progress)) {
        progress_bar.sc.image = progress_bar.image.Scale(346 * progress, progress_bar.height);
        progress_bar.sprite.SetImage(progress_bar.image);
    }
}

Plymouth.SetBootProgressFunction(progress_callback);

fun boot_progress_cb(time, progress) {
    spin.Animate(time);
    logo.sp.sprite.SetOpacity(time * 2.0);
    progress_callback (duration, progress);
}

Plymouth.SetBootProgressFunction(boot_progress_cb);

// PROGRESS FADE
status__ = "normal";

logotype.image = Image("");

progress_fade.image = Image("PROGRESS_FADE.PNG");
progress_fade.sp.sprite = Sprite(progress_fade.image);
fsck_progress_fade.image = Image("");

progress_meter.image = Image("");
progress_meter.sp.sprite = Sprite(progress_meter.image);
fsck_progress_meter.image = Image("");

counter = 0;

fade_dir = 0;

progress_meter.sp.x = progress_bar.sp.x;
progress_meter.sp.y = progress_bar.sp.y;
progress_meter.sp.sprite.SetPosition(progress_meter.sp.x, progress_meter.sp.y, 6);

fun refreshHandler() {
    if (status__ == "normal" && Plymouth.GetMode() == "boot") {
        progress_fade.sp.sprite.SetOpacity(0); // полностью прозрачный
        progress_bar.sp.sprite.SetOpacity(1);
    } else {
        progress_fade.sp.sprite.SetOpacity(1);
        progress_bar.sp.sprite.SetOpacity(0);
    }

    progress_fade.sp.sprite.SetPosition(counter + progress_bar.sp.x, progress_bar.sp.y, 6);

    if (fade_dir == 0) {
        counter++;
    if (counter >= 290) {
        fade_dir = 1;
    }
    } else {
        counter--;
    if (counter <= 0) {
        fade_dir = 0;
    }
    }

    if ((fsck_running == 1) && (fsck_done_fading == 0)) {
        fsck_progress_meter.sp.sprite.SetOpacity(fsck_fade_in_counter);
        fsck_progress_fade.sp.sprite.SetOpacity(fsck_fade_in_counter);

        if (fsck_fade_in_counter < 1) {
            fsck_fade_in_counter+= 0.025;
        } else {
            fsck_done_fading = 1;
        }
    }

    update();
}

Plymouth.SetRefreshFunction(refreshHandler);

// Status Update
NUM_SCROLL_LINES = 10;
LINE_WIDTH = 55;

// width of one character doesnt work
CHAR_WIDTH = 7;
// height of one character
CHAR_HEIGHT = 10;

// msg_color is array
msg_color = [1, 1, 1];

// status callback
fun update_status_callback(status__) {
    if (status__ == "failed") msg_color = [1,0,0];
    if (status__ == "warning") msg_color = [0.8,0.8,0];
    if (status__ == "normal") msg_color = [0.5,0.5,0.5];
}

// Initialising text images and their positions
// 20 is the height (including line spacing) of each line
for (i=0; i < NUM_SCROLL_LINES; i++) {
    lines[i]= Image.Text("", msg_color[0], msg_color[1], msg_color[2]);
    message_sprite[i] = Sprite();
    message_sprite[i].SetPosition(progress_bar.sp.x, (progress_bar.sp.y + progress_bar.height + 10) + (i * 20), 10000);
}

fun StringLength(string) {
    index = 0;
    str = String(string);
    while (str.CharAt(index)) index++;
    return index;
}

pretext = String("");

fun scroll_message_callback(text) {
    nobreak = 0;
    if (text.CharAt(0) == ">") {
        // "no linebreak" flag, like "-n"
        // remove ">" at front
        text = text.SubString(1, StringLength(text));
        nobreak = 1;
    }

    if ((pretext == "") || (StringLength(text) > 2)) {
        // ignore messages of only a single dot
        if (text == ".") {
            return;
        }

        if (nobreak == 1) {
            pretext = text;
        }

        // Truncate the message if too long
        if (StringLength(text) > LINE_WIDTH) {
            text = text.SubString(0, LINE_WIDTH - 3);
            text += "...";
        }

        // Shift message one up
        for (i = 0; i < NUM_SCROLL_LINES - 1; i++) {
            lines[i] = lines[i+1];
        }
    } else {
    // the previous message was flagged to have no linebreak

    // Truncate the message if too long
    if (StringLength(text) > LINE_WIDTH - 5) {
        // leave min. 5 for pretext
        text = text.SubString(0, LINE_WIDTH - 8);
        text += "...";
    }

    // Truncate the previous message if too long
    if (StringLength(pretext) > (LINE_WIDTH - StringLength(text))) {
        pretext = pretext.SubString(0, LINE_WIDTH - StringLength(text) - 3);
        pretext += "...";
    }

    text = pretext + text;
        if (nobreak == 1) {
            pretext = text;
        } else {
            pretext = ">";
        }
    }

    // Create the image for the latest message
    lines[i] = Image.Text(text, msg_color[0], msg_color[1], msg_color[2]);

    // Re-positioning the text images
    for (i = 0; i < NUM_SCROLL_LINES; i++) {
        message_sprite[i].SetImage(lines[i]);
    }
}

Plymouth.SetUpdateStatusFunction(update_status_callback);

Plymouth.SetUpdateStatusFunction(scroll_message_callback);

// DIALOGUE
status__ = "normal";

fun dialog_setup() {
    local.box;
    local.lock;
    local.entry;
    local.text;

    box.image = Image("BOX.PNG");
    lock.image = Image("LOCK.PNG");
    entry.image = Image("ENTRY.PNG");

    box.sprite = Sprite(box.image);
    box.x = percent(75, screen.width) - box.image.GetWidth () / 2;
    box.y = percent(60, screen.height) - box.image.GetHeight() / 2;
    box.z = 100;
    box.sprite.SetPosition(box.x, box.y, box.z);

    lock.sprite = Sprite(lock.image);
    lock.x = box.x + 25;
    lock.y = box.y + 30;
    lock.z = box.z + 1;
    lock.sprite.SetPosition(lock.x, lock.y, lock.z);

    entry.sprite = Sprite(entry.image);
    entry.x = box.x + 80;
    entry.y = box.y + 35;
    entry.z = box.z + 1;
    entry.sprite.SetPosition(entry.x, entry.y, entry.z);

    prompt_sprite = SpriteNew();
    prompt_sprite.SetPosition(prompt_sprite.x, prompt_sprite.y, prompt_sprite.z);
    prompt_sprite.SetPosition(box.x + 46, box.y - 21, box.z);

    global.dialog.box = box;
    global.dialog.lock = lock;
    global.dialog.entry = entry;
    global.dialog.text = text_pass;
    global.dialog.bullet_image = Image("BULLET.PNG");
    global.dialog.prompt_sprite = prompt_sprite;
    dialog_opacity(1);
}

fun dialog_opacity(opacity) {
    dialog.box.sprite.SetOpacity (opacity);
    dialog.lock.sprite.SetOpacity (opacity);
    dialog.entry.sprite.SetOpacity (opacity);
    dialog.text.sprite.SetOpacity (opacity);
    dialog.prompt_sprite.SetOpacity(opacity);

    for (index = 0; dialog.bullet[index]; index++) {
        dialog.bullet[index].sprite.SetOpacity(opacity);
    }
}

fun display_normal_callback() {
    global.status__ = "normal";
    if (global.dialog) {
        dialog_opacity (0);
    }
}

fun display_password_callback(prompt, bullets) {
    global.status__ = "password";

    if (!global.dialog) {
        dialog_setup();
    } else {
        dialog_opacity(1);
    }

    dialog.prompt_sprite.SetImage(Image.Text(prompt, 0.8,0.8,0.8,1, passwordfont));

    for (index = 0; dialog.bullet[index] || index < bullets; index++) {
        if (!dialog.bullet[index]) {
            dialog.bullet[index].sprite = Sprite(dialog.bullet_image);
            // отступ точки от точки и от поля (modified)
            dialog.bullet[index].x = dialog.entry.x + index * dialog.bullet_image.GetWidth() / 0.8 - dialog.entry.image.GetHeight() * -0.2;
            dialog.bullet[index].y = dialog.entry.y + dialog.entry.image.GetHeight() / 1.9 - dialog.bullet_image.GetHeight() / 2;
            dialog.bullet[index].z = dialog.entry.z + 1;
            dialog.bullet[index].sprite.SetPosition(dialog.bullet[index].x, dialog.bullet[index].y, dialog.bullet[index].z);
        }

        if (index < bullets) {
            dialog.bullet[index].sprite.SetOpacity(1);
        } else {
            dialog.bullet[index].sprite.SetOpacity(0);
        }
    }
}

fun display_message_callback(prompt) {
    prompt = Image.Text(prompt,0.0,0.0,0.0,1);
    sprite_prompt.SetImage(prompt);
    sprite_prompt.SetPosition(x0 + (screen_width - prompt.GetWidth()) / 2, y0 + screen_height * 0.10, 2);
}

Plymouth.SetDisplayNormalFunction(display_normal_callback);
Plymouth.SetDisplayPasswordFunction(display_password_callback);
Plymouth.SetMessageFunction(display_message_callback);

// QUIT
fun quit_callback() {
    progress_fade_sprite.SetOpacity (1);
    progress_bar.sprite.SetOpacity (0);
}

Plymouth.SetQuitFunction(quit_callback);
